Linux中，管理整个计算机硬件的其实是操作系统的内核(kernel)，这个内核是需要被保护的。 所以一般使用者就只能通过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。所以shell可以说是与内核进行交互的应用程序，它提供接口给操作者，去与内核以及其他应用程序进行交互。当然，最直观的shell表达就是：命令行。  
Linux的shell有很多种，例如sh、bash、csh、tcsh、ash 等等。其中最常用的就是bash，所以这里也就仅介绍最常用的shell。  
##bash的变量
+ **变量**    

和很多程序语言一样，bash提供了变量功能，以此来简化指令的输入内容，同时也利于后续的自动化操作。同时bash的变量是弱类型的，使得变量使用变得更加方便。  
变量的赋值十分简单，使用等号即可赋值，如`test="Hello World"`即可将Hello World赋值给test。需要注意的是，变量名称只能是英文字母与数字，但是开头字符不能是数字；同时等号两边不能有空格；如果变量内容有空格则需要双引号或者单引号将变量内容括起来。  
需要获取变量的值时，则需要使用`$`符号，如`$test`或者`${test}`会取出test变量中的具体内容。需要注意的是获取一个没有赋过值的变量则会取出空内容。如图   
![](imgs/linux_3.png)
对于未赋值的变量，它的值为空。同时可以使用`unset`指令清空变量的值。    
单引号和双引号可以将变量内容结合起来，双引号会保留符号以及指令的原本特性，单引号则会变为一般字符串。   
```
LANG=zh_TW.UTF-8
var="lang is $LANG"   #var 的值为 lang is zh_TW.UTF-8
var='lang is $LANG'   #var 的值为 lang is $LANG
```
+ **环境变量**   

上面讲的是shell变量，是作用于一个shell程序内的，还有一种变量称作环境变量，是作用于程序之间的变量。  
使用`env`指令可以列出所有环境变量，使用`set`可以列出所有自订变量和环境变量。  
使用`export`指令可以自己设定环境变量，如`export MYENV=50`。  
环境变量名由大写字母，下划线以及数字组成，同时数字与下划线不能为第一位。

此外还有特殊符号变量，都有特殊的含义：          
+ $# 是传给脚本的参数个数               
+ $0 是脚本本身的文件名            
+ $1 是脚本后接的第一个参数            
+ $2 是脚本后接的第二个参数        
+ $@ 是传给脚本的所有参数列表，"$1" "$2" "$3" … "$n"      
+ $* 是以一个单字符串显示传给脚本的所有参数，"$1 $2 $3 … $n"        
+ $$ 是脚本运行的当前进程ID号          
+ $? 是最后运行命令的结束状态码，0表示没有错误，其他表示有错误      
使用`shift`指令可以移动变量指针，改变变量指针指向的变量，即改变变量编号(例如$2变成$4)    
  
##数据流重定向
数据流重定向包括输入流，输出流和错误流。重定向就是说将原本输出到屏幕以及从键盘输入的数据改为从其他地方获取数据或者输出数据。     
+ 标准输入流代码为0，重定向使用 < 或 <<;     
+ 标准输出流代码为1，重定向使用 > 或 >>;    
+ 标准错误流代码为2，重定向使用 2> 或 2>>;   
输入流从定向会将输出重定向到某个东西的输入，如`cat > test`。输出流则是将某个输出当作某个东西的输入，如`cat < test`。错误流则是将报错信息输入到某个地方，如`ls abcd 2> test`。    
对于输出和错误流，>表示覆盖模式，>>表示添加模式。输入流中<表示将内容输入，<<表示结束符输入。    
```
cat > test;     cat >> test
ls abcd 2>test; ls abcd 2>>test    #假设abcd文件夹不存在
cat < test;     cat << eof
```
对于指令，还有特殊符号; ，&&和||。他们是用来判断多条指令的执行顺序的: 
`cmd1; cmd2`:不考虑任何条件连续按顺序执行cmd1和cmd2     
`cmd1 && cmd2`:若cmd1执行完毕且正确执行($?=0)，则开始执行cmd2。若cmd1执行完毕且为错误($?≠0)，则cmd2不执行。    
`cmd1 || cmd2`:若cmd1执行完毕且正确执行($?=0)，则cmd2不执行。若cmd1执行完毕且为错误($?≠0)，则开始执行cmd2。    
